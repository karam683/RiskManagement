"use strict";
const ruleFactory_1 = require("../ruleFactory");
const Annotations = {
    ModelCheckIgnore: "@AFC.Model.Check.Ignore",
    Source: "@AFC.Source",
    MasterDataSource: "@AFC.MasterData.Source",
    ConfigSource: "@AFC.Config.Source",
    ChangelogExternalEntityKey: "@AFC.Changelog.ExternalEntity.Key",
    ChangelogExternalEntityText: "@AFC.Changelog.ExternalEntity.Text",
    ChangelogExternalEntityTextKey: "@AFC.Changelog.ExternalEntity.TextKey",
    ChangelogIgnoredCompositions: "@AFC.Changelog.IgnoredCompositions",
    PopulatedBy: "@AFC.PopulatedBy",
    PopulatedByParent: "@AFC.PopulatedBy.Parent",
    Enum: "@AFC.Enum",
    EnumText: "@AFC.Enum.Text",
};
const Severity = {
    Error: "E",
    Warning: "W",
    Info: "I",
};
function getInfoFromCSN(cds, csn, result) {
    let loc = {
        start: { line: 0, column: 0 },
        end: { line: 1, column: 0 }
    };
    let file;
    const resultSplit = result.toString().split(':');
    const resultCombSplit = `${resultSplit[1]}`.split('~>');
    const entity = resultCombSplit[0].trim();
    if (csn && csn.definitions && csn.definitions[entity]) {
        const entityObject = csn.definitions[entity];
        if (entityObject.$location) {
            loc = cds.getLocation(entity, entityObject);
            file = entityObject.$location.file;
        }
    }
    return { file, loc };
}
function associationCardinalityFlaw(csn) {
    const messages = [];
    processEntity(csn, (definition, sourceEntity, sourceAlias) => {
        let refCardinalityMult = false;
        let refPlainElement = false;
        processElement(csn, definition, sourceEntity, sourceAlias, () => {
            refCardinalityMult = false;
            refPlainElement = false;
        }, (refEntity, refElement) => {
            if (refElement.type === "cds.Association" || refElement.type === "cds.Composition") {
                if (refElement.cardinality && refElement.cardinality.max === "*") {
                    refCardinalityMult = true;
                }
            }
            else {
                refPlainElement = true;
            }
        }, (column) => {
            if (definition.keys &&
                Object.keys(definition.keys).length === 1 &&
                Object.keys(definition.keys)[0] === "ID" &&
                refCardinalityMult &&
                refPlainElement) {
                report(messages, Severity.Error, "InvalidAssociationCardinality", definition, column, '');
            }
        });
    });
    return [messages];
}
function processEntity(csn, eachCallback) {
    Object.keys(csn.definitions).forEach((name) => {
        if (name.startsWith("localized.")) {
            return;
        }
        const definition = csn.definitions[name];
        if (definition.kind === "entity" &&
            definition.query &&
            definition.query.SELECT &&
            definition.query.SELECT.columns) {
            let sourceEntity;
            const sourceAlias = [];
            if (definition.query.SELECT.from.ref) {
                sourceEntity = csn.definitions[definition.query.SELECT.from.ref.join("_")];
                sourceAlias.push({
                    from: sourceEntity.name,
                    as: definition.query.SELECT.from.as || definition.query.SELECT.from.ref.slice(-1)[0].split(".").pop(),
                });
            }
            else if (definition.query.SELECT.from.args && definition.query.SELECT.from.args[0].ref) {
                sourceEntity = csn.definitions[definition.query.SELECT.from.args[0].ref.join("_")];
                definition.query.SELECT.from.args.forEach((arg) => {
                    sourceAlias.push({
                        from: arg.ref.join("_"),
                        as: arg.as || arg.ref.slice(-1)[0].split(".").pop(),
                    });
                });
            }
            if (!sourceEntity) {
                return;
            }
            eachCallback(definition, sourceEntity, sourceAlias);
        }
    });
}
function processElement(csn, definition, sourceEntity, sourceAlias, beforeCallback, eachCallback, afterCallback) {
    definition.query.SELECT.columns.forEach((column) => {
        if (column.ref && column.ref.length > 1) {
            let refEntity = sourceEntity;
            let refAlias = sourceAlias;
            beforeCallback();
            column.ref.forEach((ref) => {
                ref = ref.id || ref;
                const matchAlias = refAlias.find((alias) => {
                    return alias.as === ref;
                });
                let refElement;
                if (matchAlias) {
                    refEntity = csn.definitions[matchAlias.from];
                }
                else {
                    refElement = refEntity.elements[ref];
                    if (!refElement) {
                        refElement = definition.elements[ref];
                        if (!refElement && definition.query.SELECT.mixin) {
                            refElement = definition.query.SELECT.mixin[ref];
                            if (!refElement && definition.query.SELECT.mixin[column.ref[0]]) {
                                refElement = definition.query.SELECT.mixin[column.ref[0]]._target.elements[ref];
                            }
                        }
                    }
                    eachCallback(refEntity, refElement);
                    if (refElement.type === "cds.Association" || refElement.type === "cds.Composition") {
                        refEntity = csn.definitions[refElement.target];
                    }
                }
                refAlias = [];
            });
            afterCallback(column);
        }
    });
}
function report(messages, severity, code, entity, column, info) {
    if (entity && entity[Annotations.ModelCheckIgnore] && entity[Annotations.ModelCheckIgnore].includes(code)) {
        return;
    }
    if (column) {
        if (column.as &&
            entity.elements[column.as] &&
            entity.elements[column.as][Annotations.ModelCheckIgnore] &&
            entity.elements[column.as][Annotations.ModelCheckIgnore].includes(code)) {
            return;
        }
        if (column[Annotations.ModelCheckIgnore] && column[Annotations.ModelCheckIgnore].includes(code)) {
            return;
        }
    }
    const message = {
        severity: severity || Severity.Error,
        code,
        entity,
        column,
        info,
        toString: () => {
            let columnPath = "";
            if (message.column) {
                if (message.column.ref) {
                    columnPath = `${message.column.ref.map((ref) => ref.id || ref).join(".")} ${message.column.as ? ": " + message.column.as : ""}`;
                }
                else {
                    columnPath = message.column.name;
                }
            }
            return `[${message.severity}] ${message.code}: ${message.entity.name} ${columnPath ? "~> " + columnPath : ""}${message.info ? ` (${message.info})` : ""}`;
        },
    };
    messages.push(message);
    return message;
}
module.exports = ruleFactory_1.createRule({
    type: 'problem',
    docs: {
        description: `Checks for association cardinality flaw.`,
        category: 'Model Validation',
        version: '1.0.1'
    }
}, (cds, context) => {
    var _a, _b;
    const report = [];
    const filepath = context.getFilename();
    if (filepath.endsWith('.cds')) {
        let csnOdata;
        if ((_a = cds.model) === null || _a === void 0 ? void 0 : _a.definitions) {
            csnOdata = cds.compile.for.odata(cds.model);
            if (cds.model && csnOdata && ((_b = cds.model) === null || _b === void 0 ? void 0 : _b.definitions)) {
                const csnOdataLinked = cds.linked(csnOdata);
                const results = associationCardinalityFlaw(csnOdataLinked);
                results.forEach((result) => {
                    if (result.toString()) {
                        const location = getInfoFromCSN(cds, cds.model, result);
                        report.push({
                            message: result.toString(),
                            loc: location.loc,
                            file: location.file
                        });
                    }
                });
            }
        }
    }
    return report;
});
//# sourceMappingURL=assocs-card-flaw.js.map