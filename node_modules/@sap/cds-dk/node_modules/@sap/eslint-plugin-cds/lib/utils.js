"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLocation = exports.getRange = exports.printInStyle = exports.getModel = exports.getConfigPath = exports.getProxy = exports.getAST = exports.getRules = exports.Cache = void 0;
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const eslint_1 = require("eslint");
const cache = new Map();
exports.Cache = {
    has(key) {
        return cache.has(key);
    },
    set(key, value) {
        return cache.set(key, [value, Date.now()]);
    },
    get(key) {
        if (cache.get(key)) {
            return cache.get(key)[0];
        }
        else {
            return;
        }
    },
    dump() {
        const dump = {};
        for (const [key, value] of cache.entries()) {
            const timestamp = new Date(value[1]);
            dump[key] = { key, value: JSON.stringify(value[0]), timestamp };
        }
        return dump;
    },
    remove(key) {
        if (cache.has(key)) {
            cache.delete(key);
        }
        return;
    },
    clear() {
        cache.clear();
        return;
    }
};
function getRules(ruleList, ruleSeverities) {
    const ruleConfig = {};
    ruleList.forEach((rule) => {
        ruleConfig[`@sap/cds/${rule}`] = ruleSeverities[rule];
    });
    return ruleConfig;
}
exports.getRules = getRules;
function getAST(code) {
    return {
        type: 'Program',
        body: [],
        sourceType: 'module',
        tokens: [],
        comments: [],
        range: [0, code.length],
        loc: {
            start: {
                line: 1,
                column: 0
            },
            end: {
                line: 1,
                column: 0
            },
        }
    };
}
exports.getAST = getAST;
function getProxy(obj) {
    const handler = {
        get(target, prop, receiver) {
            const value = Reflect.get(target, prop, receiver);
            if (['model', 'environment'].includes(prop)) {
                return exports.Cache.get(prop);
            }
            if (typeof value !== 'object') {
                return value;
            }
            if (!!value) {
                return new Proxy(value, handler);
            }
            return { err: `Property ${prop} prop does not exist on object ${obj}!` };
        },
        apply(target, thisArg, argumentsList) {
            const result = Reflect.apply(target, this, argumentsList);
            return result;
        }
    };
    return new Proxy(obj, handler);
}
exports.getProxy = getProxy;
function getConfigPath(currentDir = ".") {
    const configFiles = [
        ".eslintrc.js",
        ".eslintrc.cjs",
        ".eslintrc.yaml",
        ".eslintrc.yml",
        ".eslintrc.json",
        ".eslintrc",
        "package.json",
    ];
    let configDir = path.resolve(currentDir);
    while (configDir !== path.resolve(configDir, "..")) {
        for (let i = 0; i < configFiles.length; i++) {
            const configPath = path.join(configDir, configFiles[i]);
            if (fs.existsSync(configPath) && fs.statSync(configPath).isFile()) {
                return configPath;
            }
        }
        configDir = path.join(configDir, "..");
    }
    throw new Error('Couldn\'t find an ESLint configuration file!');
}
exports.getConfigPath = getConfigPath;
function getModel(code = '') {
    let cdsObject;
    let configPath;
    let files;
    if (!exports.Cache.has('configpath')) {
        configPath = path.dirname(this.getConfigPath());
        exports.Cache.set('configpath', configPath);
    }
    else {
        configPath = exports.Cache.get('configpath');
    }
    if (!exports.Cache.has('modelfiles')) {
        files = cds.resolve('*', { cwd: path.dirname(configPath) });
        exports.Cache.set('modelfiles', files);
    }
    else {
        files = exports.Cache.get('modelfiles');
    }
    if (process.argv[1].includes('jest') || process.argv[1].includes('mocha')) {
        if (code) {
            cdsObject = cds.compile.to.csn(code);
        }
    }
    else {
        try {
            const dictFiles = {};
            if (files) {
                files.forEach((file) => {
                    dictFiles[file] = exports.Cache.get(`file:${file}`) || fs.readFileSync(file, 'utf8');
                });
                const namespaces = [];
                Object.values(dictFiles).forEach((v) => {
                    if (v.includes('namespace ')) {
                        const match = v.match(/namespace[\s]+.+;/);
                        if (match && match[0]) {
                            const namespace = match[0].replace('namespace ', '').replace(';', '');
                            if (namespace && !namespaces.includes(namespace)) {
                                namespaces.push(namespace);
                            }
                        }
                    }
                });
                cdsObject = cds.compile.to.csn(dictFiles, { sync: true, locations: true });
                cdsObject.namespaces = namespaces;
                cdsObject.files = files;
            }
        }
        catch (err) {
            cdsObject = { err: err.message };
        }
    }
    exports.Cache.set('model', cdsObject);
    return cdsObject;
}
exports.getModel = getModel;
function printInStyle(msg, styles) {
    const types = {
        reset: '\x1b[0m',
        bold: '\x1b[1m',
        link: '\x1b[4m',
        red: '\x1b[91m',
        green: '\x1b[32m',
        orange: '\x1b[38;2;255;140;0m'
    };
    let msgStyle = '';
    styles.forEach((style) => {
        msgStyle += types[style];
    });
    console.log(`${msgStyle}${msg}${types['reset']}`);
}
exports.printInStyle = printInStyle;
function getRange(code, line, column) {
    let lines;
    if (typeof code === 'string') {
        lines = eslint_1.SourceCode.splitLines(code);
    }
    else {
        lines = code;
    }
    const ranges = [0];
    lines.forEach((line, i) => {
        if (i === 0) {
            ranges[i + 1] = line.length + 1;
        }
        else {
            ranges[i + 1] = ranges[i] + line.length + 1;
        }
    });
    if (line > 1) {
        return ranges[line - 1] + column;
    }
    else {
        return column;
    }
}
exports.getRange = getRange;
function getLocation(name, obj) {
    const loc = {
        start: { line: 0, column: 0 },
        end: { line: 1, column: 0 }
    };
    if (obj.$location) {
        const nameloc = obj.$location;
        if (nameloc.col === 0) {
            nameloc.col = 1;
        }
        loc.start.column = nameloc.col - 1;
        loc.start.line = nameloc.line;
        loc.end.column = nameloc.col - 1 + name.length;
        loc.end.line = nameloc.line;
    }
    return loc;
}
exports.getLocation = getLocation;
//# sourceMappingURL=utils.js.map