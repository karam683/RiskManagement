"use strict";
const chalk = require("chalk");
const stripAnsi = require("strip-ansi");
const table = require("text-table");
const utils_1 = require("./utils");
function pluralize(word, count) {
    return (count === 1 ? word : `${word}s`);
}
function createTable(messages, summaryColor) {
    const results = messages.map((message) => {
        let messageType;
        if (message.fatal || message.severity === 2) {
            messageType = chalk.red("error");
            summaryColor = "red";
        }
        else {
            messageType = chalk.yellow("warning");
        }
        return [
            "",
            message.line || 0,
            message.column || 0,
            messageType,
            message.message.replace(/([^ ])\.$/u, "$1"),
            chalk.dim(message.ruleId || "")
        ];
    }).filter(function (element) {
        return element !== undefined;
    });
    return `${table(results, {
        align: ["", "r", "l"],
        stringLength(str) {
            return stripAnsi(str).length;
        }
    }).split("\n").map((el) => el.replace(/(\d+)\s+(\d+)/u, (m, p1, p2) => chalk.dim(`${p1}:${p2}`))).join("\n")}\n\n`;
}
function createTableEnv(messages, summaryColor) {
    const results = messages.map((message) => {
        let messageType;
        if (message.fatal || message.severity === 2) {
            messageType = chalk.red("error");
            summaryColor = "red";
        }
        else {
            messageType = chalk.yellow("warning");
        }
        return [
            "",
            messageType,
            message.message.replace(/([^ ])\.$/u, "$1"),
            chalk.dim(message.ruleId || "")
        ];
    }).filter(function (element) {
        return element !== undefined;
    });
    return `${table(results, {
        align: ["", "r", "l"],
        stringLength(str) {
            return stripAnsi(str).length;
        }
    })}\n\n`;
}
module.exports = function (results, data) {
    let output = "\n", errorCount = 0, warningCount = 0, fixableErrorCount = 0, fixableWarningCount = 0;
    let summaryColor = "yellow";
    const messagesEnv = [];
    const messagesModel = {};
    const messagesOther = {};
    results.forEach(result => {
        const messages = result.messages;
        if (messages.length === 0) {
            return;
        }
        errorCount += result.errorCount;
        warningCount += result.warningCount;
        fixableErrorCount += result.fixableErrorCount;
        fixableWarningCount += result.fixableWarningCount;
        messages.forEach((msg) => {
            let category;
            if (msg.ruleId in data.rulesMeta) {
                category = data.rulesMeta[msg.ruleId].docs.category;
            }
            else if (`@sap/cds/${msg.ruleId}` in data.rulesMeta) {
                category = data.rulesMeta[`@sap/cds/${msg.ruleId}`].docs.category;
            }
            if (category === 'Environment') {
                messagesEnv.push(msg);
            }
            else if (category === 'Model Validation') {
                if (!messagesModel.hasOwnProperty(result.filePath)) {
                    messagesModel[result.filePath] = [];
                }
                messagesModel[result.filePath].push(msg);
            }
            else {
                if (!messagesOther.hasOwnProperty(result.filePath)) {
                    messagesOther[result.filePath] = [];
                }
                messagesOther[result.filePath].push(msg);
            }
        });
    });
    if (!utils_1.Cache.has('err')) {
        if (messagesEnv.length > 0) {
            output += createTableEnv(messagesEnv, summaryColor);
        }
        else {
            output += chalk.green.bold('\u2713  All environment checks passed!\n\n');
        }
        if (Object.keys(messagesModel).length > 0) {
            Object.keys(messagesModel).forEach((file) => {
                output += `${chalk.underline(file)}\n`;
                output += createTable(messagesModel[file], summaryColor);
            });
        }
        else {
            output += chalk.green.bold('\u2713  All model checks passed!\n\n');
        }
        if (Object.keys(messagesOther).length > 0) {
            Object.keys(messagesOther).forEach((file) => {
                output += `${chalk.underline(file)}\n`;
                output += createTable(messagesOther[file], summaryColor);
            });
        }
        const total = errorCount + warningCount;
        if (errorCount > 0) {
            summaryColor = "red";
        }
        else if (warningCount > 0) {
            summaryColor = "yellow";
        }
        if (total > 0) {
            output += chalk[summaryColor].bold([
                "\n\u2716 ", total, pluralize(" problem", total),
                " (", errorCount, pluralize(" error", errorCount), ", ",
                warningCount, pluralize(" warning", warningCount), ")\n"
            ].join(""));
            if (fixableErrorCount > 0 || fixableWarningCount > 0) {
                output += chalk[summaryColor].bold([
                    "  ", fixableErrorCount, pluralize(" error", fixableErrorCount), " and ",
                    fixableWarningCount, pluralize(" warning", fixableWarningCount),
                    " potentially fixable with the `--fix` option.\n"
                ].join(""));
            }
        }
    }
    return chalk.reset(output);
};
//# sourceMappingURL=formatter.js.map