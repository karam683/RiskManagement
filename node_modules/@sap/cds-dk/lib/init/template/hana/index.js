const path = require('path');

const commandUtil = require('../../util/commandUtil');
const mvnArchetypes = require('../../util/mvnArchetypeUtil');
const term = require('../../../util/term');

const TemplateBase = require('../templateBase');

const { PROJECT_TYPE, OPTION_JAVA, KIND_SQL, URLS, KIND_HANA } = require('../../constants');
const { nullLogger } = require('../../util/logger');


module.exports = class HanaTemplate extends TemplateBase {
    constructor(projectPath, generator) {
        super(projectPath, generator, __dirname);

        this.env = null;
    }

    async checkEnabled() {
        if (this.options.force) {
            return true;
        }

        this.env = await this.getEnv(true);

        const hdiConfigPath = path.join(this.projectPath, this.env.folders.db, 'src/.hdiconfig');
        if (await this.fsUtil.pathExists(hdiConfigPath)) {
            const configFilePath = path.join(this.env.folders.db, 'src/.hdiconfig');
            throw new Error(`Database config file ${configFilePath} already exists. Use --force to overwrite.`);
        }

        return true;
    }

    // read env from project
    async getEnv(force) {
        const cdsEnvVar = process.env.CDS_ENV;
        process.env.CDS_ENV = 'production'
        let env
        try {
            env = await super.getEnv(force);
        } finally {
            cdsEnvVar ? process.env.CDS_ENV = cdsEnvVar : delete process.env.CDS_ENV
        }
        return env
    }

    async run() {
        this.env = await this.getEnv(true);

        await this.templateUtil.copyFiles('common', path.join(this.projectPath, this.env.folders.db), {
            projectName: this.projectName
        }, this.options.force);

        const cdsrcJsonPath = path.join(this.projectPath, '.cdsrc.json');
        const projectType = await this.getProjectType();
        switch (projectType) {
            case PROJECT_TYPE.java:
                await this.templateUtil.copyFiles('java', path.join(this.projectPath, this.env.folders.db), {}, this.options.force);
                await this._updatePomXml();
                await this._updateCdsrcJson(cdsrcJsonPath, this.env.folders.db);
                break;

            case PROJECT_TYPE.nodejs:
                await this._updatePackageJson(path.join(this.projectPath, 'package.json'), this.env.folders.db);
                break;

            default: break;
        }
    }

    async _updatePomXml() {
        // if called during cds init the project generation call to AT will add settings
        if (!this.options.add.has(OPTION_JAVA)) {
            const mvnAddHanaArgs = mvnArchetypes.getAddHanaCmdArgs(this.options);
            try {
                await commandUtil.spawnCommand('mvn', mvnAddHanaArgs, {
                    cwd: this.projectPath
                }, (this.logger.isDebug ? this.logger : nullLogger));
            } catch (err) {
                if (err.code === 'ENOENT' && err.path === 'mvn') {
                    throw new Error(`Maven executable 'mvn' not found, follow ${term.info(URLS.MAVEN_INSTALL_HELP)} and install Maven on your machine.`);
                }
                throw err;
            }
        }
    }

    async _updatePackageJson(packageJsonPath, modelName) { //NOSONAR
        modelName = path.basename(modelName);

        if (!await this.fsUtil.pathExists(packageJsonPath)) {
            throw new Error(`package.json not found in project. ${packageJsonPath}`);
        }

        let changed;
        const packageJson = await this.fsUtil.readJSON(packageJsonPath);

        this.logger.isDebug && this.logger.debug(`_updatePackageJson before: ${JSON.stringify(packageJson, null, 2)}`);

        if (!packageJson.dependencies || (!packageJson.dependencies.hdb && !packageJson.dependencies['@sap/hana-client'])) {
            packageJson.dependencies = packageJson.dependencies || {};
            packageJson.dependencies['@sap/hana-client'] = '^2.6.61';
            changed = true;
        }

        if (!this._isUsingHana(modelName)) {
            packageJson.cds = packageJson.cds || {};
            packageJson.cds.requires = packageJson.cds.requires || {};
            packageJson.cds.requires[modelName] = packageJson.cds.requires[modelName] || {};
            packageJson.cds.requires[modelName].kind = KIND_SQL;
            changed = true;
        }

        if (!packageJson.cds || !packageJson.cds.hana || !packageJson.cds.hana['deploy-format']) {
            packageJson.cds = packageJson.cds || {};
            packageJson.cds.hana = packageJson.cds.hana || {}
            packageJson.cds.hana['deploy-format'] = 'hdbtable'
            changed = true;
        }

        if (changed) {
            await this.fsUtil.writeJSON(packageJsonPath, packageJson);
            this.logger.isDebug && this.logger.debug(`_updatePackageJson written: ${JSON.stringify(packageJson, null, 2)}`);
        }
    }

    async _updateCdsrcJson(cdsrcJsonPath, modelName) {
        modelName = path.basename(modelName);

        let changed;
        let cdsrcJson = {}
        try {
            cdsrcJson = await this.fsUtil.readJSON(cdsrcJsonPath);
        } catch (err) {
            //
        }

        this.logger.isDebug && this.logger.debug(`_updateCdsrcJson before: ${JSON.stringify(cdsrcJson, null, 2)}`);

        if (!this._isUsingHana(modelName)) {
            cdsrcJson.requires = cdsrcJson.requires || {};
            cdsrcJson.requires[modelName] = cdsrcJson.requires[modelName] || {};
            cdsrcJson.requires[modelName].kind = KIND_SQL;
            changed = true
        }
        if (!cdsrcJson.hana || !cdsrcJson.hana['deploy-format']) {
            cdsrcJson.hana = cdsrcJson.hana || {}
            cdsrcJson.hana['deploy-format'] = 'hdbtable'
            changed = true
        }

        if (changed) {
            await this.fsUtil.writeJSON(cdsrcJsonPath, cdsrcJson);
            this.logger.isDebug && this.logger.debug(`_updateCdsrcJson written: ${JSON.stringify(cdsrcJson, null, 2)}`);
        }
    }

    _isUsingHana(modelName) {
        return this.env.get(`requires.${modelName}.kind`) === KIND_HANA || this.env.get(`requires.${modelName}.use`) === KIND_HANA;
    }
}
