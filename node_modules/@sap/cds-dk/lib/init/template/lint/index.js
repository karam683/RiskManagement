const fs = require("fs");
const yaml = require("@sap/cds-foss")("yaml");
const path = require("path");

const TemplateBase = require("../templateBase");
const commandUtil = require("../../util/commandUtil");
const term = require("../../../util/term");

const Linter = require("../../../lint/Linter");
const linter = new Linter();

const { URLS, OPTION_LINT_CUSTOM } = require("../../constants");

const npmDependencies = {
  eslint: "ESLint v>=6.0.0",
  "@sap/eslint-plugin-cds": "ESLint plugin for CDS @sap/eslint-plugin-cds",
};

module.exports = class LintTemplate extends TemplateBase {
  constructor(projectPath, generator) {
    super(projectPath, generator, __dirname);
    this.cdsdkPath = path.join(__dirname, '../../../..');
    this.rulesPath = path.join(projectPath, ".eslintrules");
    this.projectPath = projectPath;
    this.eslintCmd = null;
    this.eslintVersion = null;
    this.eslintCDSPlugin = "";
    this.hasVscode = false;
    this.missingNpmDependencies = { names: [], msgs: [] };
    this._getConfigPath = linter._getConfigPath.bind(this);
    this._readConfigContents = linter._readConfigContents.bind(this);
    this._checkEslintCmd = linter._checkEslintCmd.bind(this);
  }

  _installEslintCDSPlugin(projectPath) {
    // Plugin must be installed installed locally in the project
    // or exist within the @sap/cds-dk
    const plugin = "@sap/eslint-plugin-cds";
    try {
      // reachable from project dir?
      require.resolve(plugin, { paths: [projectPath] });
    } catch (error) {
      // no, so install it
      if (!fs.existsSync(path.join(projectPath, ".mock-install"))) {
        this.missingNpmDependencies["names"].push(plugin);
        this.missingNpmDependencies["msgs"].push(npmDependencies[plugin]);
        return false;
      } else {
        return true;
      }
    }
    this.eslintCDSPlugin = plugin;
  }

  async _writeConfigContents(configContents, configPath) {
    let configFile = path.basename(configPath);
    switch (configFile) {
      case ".eslintrc.js":
      case ".eslintrc.cjs":
        await this.fsUtil.writeFile(
          configPath,
          `module.exports = ${JSON.stringify(configContents, null, 2)}`
        );
        break;
      case ".eslintrc.yaml":
      case ".eslintrc.yml":
        await this.fsUtil.writeFile(configPath, yaml.stringify(configContents));
        break;
      case ".eslintrc.json":
      case ".eslintrc":
      case "package.json":
        await this.fsUtil.writeFile(
          configPath,
          `${JSON.stringify(configContents, null, 2)}`
        );
        break;
      default:
        break;
    }
    return;
  }

  async _writeVscodeSettings() {
    let settings = {};
    if (!this.settingsPath) {
      this.settingsPath = path.join(this.projectPath, ".vscode/settings.json");
    }
    if (fs.existsSync(this.settingsPath)) {
      settings = await this.fsUtil.readJSON(this.settingsPath);
    } else {
      await this.fsUtil.mkdirp(path.dirname(this.settingsPath));
    }
    settings = this._enhanceVscodeSettings(settings, this.projectPath);
    await this.fsUtil.writeJSON(this.settingsPath, settings);
    return;
  }

  _addToConfigArray(configContents, key, value) {
    if (configContents) {
      if (configContents[key]) {
        if (Array.isArray(configContents[key])) {
          if (!configContents[key].includes(value)) {
            configContents[key].push(value);
          }
        } else {
          configContents[key] = [configContents[key], value];
        }
      } else {
        configContents[key] = [value];
      }
    }
    return configContents;
  }

  _addToConfigRules(configContents, obj) {
    for (const [key, value] of Object.entries(obj)) {
      if (configContents["rules"]) {
        if (!(key in configContents["rules"])) {
          configContents["rules"][key] = value;
        }
      } else {
        configContents["rules"] = {};
        configContents["rules"][key] = value;
      }
    }
    return configContents;
  }

  _enhanceEslintConfig(configContents = {}) {
    const configType = "recommended";
    if ("root" in configContents) {
      configContents["root"] = false;
    }
    configContents = this._addToConfigArray(
      configContents,
      "extends",
      `plugin:@sap/cds/${configType}`
    );
    configContents = this._addToConfigRules(configContents, {
      "no-entity-moo": 2,
    });
    return configContents;
  }

  _enhanceVscodeSettings(settings, projectPath) {
    const lintFileTypes = ["javascript", "cds", "json", "yaml", "csn"];
    const lintRulePaths = [path.join(projectPath, ".eslint", "rules")];
    const lintConfigFile = path.join(__dirname, "../../../lint/.eslintrc.js");
    // If exists, enhance config file with plugin and extends
    if (settings) {
      if (settings["eslint.validate"]) {
        lintFileTypes.forEach((lintFileType) => {
          if (!settings["eslint.validate"].includes(lintFileType)) {
            settings["eslint.validate"].push(lintFileType);
          }
        });
      } else {
        settings["eslint.validate"] = lintFileTypes;
      }

      if (settings["eslint.options"]) {
        if (this.options.add.has(OPTION_LINT_CUSTOM)) {
          if (settings["eslint.options"]["rulePaths"]) {
            lintRulePaths.forEach((lintRulePath) => {
              if (
                !settings["eslint.options"]["rulePaths"].includes(lintRulePath)
              ) {
                settings["eslint.options"]["rulePaths"].push(lintRulePath);
              }
            });
          } else {
            settings["eslint.options"]["rulePaths"] = lintRulePaths;
          }
          if (settings["eslint.options"]["configFile"]) {
            delete settings["eslint.options"]["configFile"];
          }
        } else {
          if (settings["eslint.options"][""]) {
            if (!settings["eslint.options"]["configFile"] == lintConfigFile) {
              settings["eslint.options"]["configFile"] = lintConfigFile;
            }
          } else {
            settings["eslint.options"]["configFile"] = lintConfigFile;
            if (settings["eslint.options"]["rulePaths"]) {
              delete settings["eslint.options"]["rulePaths"];
            }
          }
        }
      } else {
        if (this.options.add.has(OPTION_LINT_CUSTOM)) {
          settings["eslint.options"] = { rulePaths: lintRulePaths };
        } else {
          settings["eslint.options"] = {
            configFile: lintConfigFile,
          };
        }
      }

      // Otherwise, create a new config file
    } else {
      settings = {
        "eslint.validate": lintFileTypes,
      };
      if (this.options.add.has(OPTION_LINT_CUSTOM)) {
        settings["eslint.options"] = { rulePaths: lintRulePaths };
      }
    }
    return settings;
  }

  async _checkEslintVscodeExtension(projectPath) {
    if (!fs.existsSync(path.join(projectPath, ".mock-install"))) {
      try {
        await commandUtil.spawnCommand("code", ["--version"], {
          cwd: this.projectPath,
        });
        this.hasVscode = true;
      } catch (err) {
        this.logger.log(`Consider installing VS Code: ${URLS.VSCODE}`);
      }
      if (this.hasVscode) {
        this.linterExtensions = await commandUtil.spawnCommand(
          "code",
          ["--list-extensions", "--category", "linters"],
          {
            cwd: this.projectPath,
          },
          undefined,
          true
        );
        if (
          this.linterExtensions &&
          this.linterExtensions.includes("dbaeumer.vscode-eslint")
        ) {
          this.hasEslintExtension = true;
        }
        if (!this.hasEslintExtension) {
          this.logger.log(
            "\n\nConsider installing the VS Code extension for ESLint:\n" +
              term.info(`'dbaeumer.vscode-eslint': ${URLS.VSCODE_ESLINT}\n`)
          );
        }
      }
    }
  }

  async run() {
    // Check for ESLint v>=6.0.0
    if (!this._checkEslintCmd(this.projectPath, false)) {
      if (!this.eslintCmd && this.options.add.has(OPTION_LINT_CUSTOM)) {
        this.missingNpmDependencies["msgs"].push(npmDependencies["eslint"]);
        this.missingNpmDependencies["names"].push("eslint");
      }
    }

    if (this.options.add.has(OPTION_LINT_CUSTOM)) {
      // Check for locally installed ESLint CDS plugin
      // If not exists, install
      if (!this.eslintCDSPlugin) {
        this._installEslintCDSPlugin(this.projectPath, this.eslintCDSPlugin);
      }

      // Find and ingest ESLint config file
      let configPath = this._getConfigPath(this.projectPath);
      let contents = this._readConfigContents(configPath);
      let configContents;
      if (path.basename(configPath) === "package.json") {
        if ("eslintConfig" in contents) {
          configContents = contents["eslintConfig"];
        } else {
          configContents = {};
        }
      } else {
        configContents = contents;
      }

      // Enhance ESLint config file with recommended plugin rules
      configContents = this._enhanceEslintConfig(configContents);
      if (path.basename(configPath) === "package.json") {
        contents["eslintConfig"] = configContents;
      } else {
        contents = configContents;
      }
      await this._writeConfigContents(contents, configPath);

      // Add custom rules dir with no-entity-moo example
      await this.templateUtil.copyFiles(".", this.projectPath, {}, true);
    }

    // Enhance ESLint VSCode extension settings
    // https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint
    if (!this.hasVscode && !this.hasEslintExtension) {
      await this._checkEslintVscodeExtension(this.projectPath);
      await this._writeVscodeSettings();
    }
  }

  async finalize() {
    if (this.missingNpmDependencies["names"].length > 0) {
      let todos =
        "\n\nAlmost done - you are missing " +
        this.missingNpmDependencies["names"].length +
        " lint dependencies.\n" +
        "Please install the following components:\n\n";
      for (let i = 0; i < this.missingNpmDependencies["msgs"].length; i++) {
        todos +=
          "(" + (i + 1) + ") " + this.missingNpmDependencies["msgs"][i] + "\n";
      }
      todos += `\n    ${term.warn(
        `npm install --save-dev ${this.missingNpmDependencies["names"].join(
          " "
        )}\n`
      )}`;
      this.logger.log(todos);
    }
  }
};
