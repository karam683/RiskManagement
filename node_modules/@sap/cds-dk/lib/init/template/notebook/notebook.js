
const { Parser } = require('htmlparser2');
const codeTypes = ['language-sh', 'language-bash', 'language-js', 'language-javascript', 'language-swift', 'language-sql'];
const codeStartTags = ['%%writefile ', '!'];
const displays = { 'welcome': "<iframe src='http://localhost:4004' width=1000 height=600 style='background-color:white'></iframe>" }
let baseURL;
let route;

function tag2Element(tag, attribs) {
    const element = {};
    if (attribs) {
        if (attribs.href) {
            const routes = route.split('/');
            routes.pop();
            const routeDot = routes.join('/');
            routes.pop();
            const routeDots = routes.join('/');
            element.href = attribs.href.replace(/^\.\./g, `${baseURL}${routeDots}`)
                .replace(/^\./g, `${baseURL}${routeDot}`)
                .replace(/^#/g, `${baseURL}${route}#`)
                .replace(/^\/pages\/cap/g, `${baseURL}/docs`)
                .replace(/^\/cap/g, `${baseURL}/docs`)
                .replace(/^\/docs/g, `${baseURL}/docs`);
        }
        if (attribs.src) {
            const routes = route.split('/');
            routes.pop();
            const routeDot = routes.join('/');
            routes.pop();
            const routeDots = routes.join('/');
            element.src = attribs.src.replace(/^\.\./g, `${baseURL}${routeDots}`)
                .replace(/^\./g, `${baseURL}${routeDot}`)
                .replace(/^#/g, `${baseURL}${route}#`)
                .replace(/^\/pages\/cap/g, `${baseURL}/docs`)
                .replace(/^\/cap/g, `${baseURL}/docs`)
                .replace(/^\/docs/g, `${baseURL}/docs`);
        }
        if (attribs.class) {
            element.class = attribs.class;
        }
        if (attribs.id) {
            element.id = attribs.id;
        }
    }
    if (tag) {
        element.tag = tag;
    }
    return element;
}

function tags2Markdown(tag, element) {
    let mdTags = ['', ''];
    let mdType = 'markdown';
    switch (tag) {
        case 'a':
            if (element.class && element.class.includes('learn-more')) {
                mdTags = ['\n  тоб   [', `](${element.href})\n\n`];
            } else {
                mdTags = ['[', `](${element.href})`];
            }
            break;
        case 'blockquote':
            mdTags = ['\n> ', '\n'];
            break;
        case 'br':
            mdTags = ['', '\n\n'];
            break;
        case 'code':
            mdType = 'markdown';
            if (element.class) {
                if (element.class.includes('language-plaintext')) {
                    mdTags = ['`', '`'];
                    mdType = 'markdown';
                } else {
                    mdType = 'code';
                }
            }
            break;
        case 'del':
            mdTags = ['~~', '~~'];
            break;
        case 'div':
            if (element.class) {
                if (codeTypes.some(codeType => element.class.includes(codeType))) {
                    mdType = 'code';
                    if (element.class.includes('language-sh') ||
                        element.class.includes('language-bash')) {
                        mdTags = ['!', ''];
                    }
                } else if (element.class.includes('language-json')) {
                    mdTags = ['```json', '```'];
                    mdType = 'markdown';
                }
            }
            break;
        case 'em':
            mdTags = ['*', '*'];
            break;
        case 'h1':
            mdTags = ['\n# ', '\n'];
            break;
        case 'h2':
            if (element.id) {
                mdTags = ['## ', `<a id="${element.id}"></a>\n`];
            } else {
                mdTags = ['## ', `\n`];
            }
            break;
        case 'h3':
            mdTags = ['### ', '\n'];
            break;
        case 'h4':
            mdTags = ['#### ', '\n'];
            break;
        case 'h5':
            mdTags = ['##### ', '\n'];
            break;
        case 'h6':
            mdTags = ['###### ', '\n'];
            break;
        case 'hr':
            mdTags = ['---', '\n'];
            break;
        case 'iframe':
            mdType = 'code';
            mdTags = [`%%html\n<iframe src=${element.src} width=1000 height=600 style="background-color:white"></iframe>`, '\n'];
            break;
        case 'img':
            mdTags = ['!', `[IMAGE](${element.src})\n`];
            break;
        case 'li':
            mdTags = ['\n- ', '\n'];
            break;
        case 'p':
            if (element.class === 'subtitle') {
                mdTags = ['## ', '\n'];
            } else if (element.class === 'sample-label') {
                mdTags = ['%%writefile ', '\n'];
            } else {
                mdTags = ['', '\n'];
            }
            break;
        case 'pre':
            if (element.class) {
                if (element.class.includes('log')) {
                    mdTags = ['<pre><code>', '</pre></code>\n'];
                }
            } else {
                mdTags = ['<pre>', '</pre>\n'];
            }
            break;
        case 'strong':
            mdTags = ['**', '**'];
            break;
        case 'style':
            mdTags = ['<style>', '</style>\n'];
            break;
        default:
            break;
    }
    return { tags: mdTags, type: mdType };
}

function checkHtmlComments(comment, inContent, inExclusion, showHtml) {
    comment = comment.trim();
    if (['CONTENT START'].includes(comment)) {
        inContent = true;
    } else if (inContent && ['CONTENT END'].includes(comment)) {
        inContent = false;
    } else if (inContent && ['EXCLUDE IN NOTEBOOK START'].includes(comment)) {
        inExclusion = true;
    } else if (inContent && inExclusion && ['EXCLUDE IN NOTEBOOK END'].includes(comment)) {
        inExclusion = false;
    } else if (inContent && !inExclusion && ['INCLUDE IN NOTEBOOK [welcome]'].includes(comment)) {
        const name = comment.split('INCLUDE IN NOTEBOOK [')[1].split(']')[0].trim();
        showHtml = displays[name];
    }
    return { inContent: inContent, inExclusion: inExclusion, showHtml };
}

module.exports = class Notebook {
    constructor(args) {
        this.name = args.name;
        this.nb = args.nb;
        this.html = args.html;
        baseURL = args.url;
        route = args.route;
        this.cells = [];
        return this.html2Notebook();
    }

    // Adjust capire content to notebook flow
    sanitizeNotebook(content, type) {
        if (content.includes('%%writefile ')) {
            content = content.split(']')[0].replace('[', '"') + '"';
        }
        if (content.includes('!cds init ')) {
            content = '';
        }
        if (content.includes('cf push ')) {
            content = content.replace('cf push ', '!cf push ');
        }
        if (content.includes('!cds watch ')) {
            content = '!cds watch';
        }
        if (content.includes('create a project with minimal defaults as follows:')) {
            content = ', `cds init` has already created a project with minimal defaults for us.'
        }
        if (content.includes('%%writefile "db/data/sap.capire.bookshop-Books.csv"')) {
            this.openCell('code', '%cd db\n%mkdir data\n%cd ..');
        }
        if (content.includes('> ') && !content.includes('> filling') && type === 'markdown') {
            content = content.replace(/[\s]+>[\s\n]+/, '> ');
        }
        return content;
    }

    // Convert capire html to notebook
    html2Notebook() {
        let md = '';
        const mdArray = [];
        const tagsActive = []
        const typesActive = [];
        let inContent = false;
        let inExclusion = false;
        let showHtml;
        let markAsCode = false;
        let element = { tags: [] };
        const parser = new Parser({
            oncomment(comment) {
                const commentChecks = checkHtmlComments(comment, inContent, inExclusion, showHtml);
                inContent = commentChecks.inContent;
                inExclusion = commentChecks.inExclusion;
                showHtml = commentChecks.showHtml;
            },
            onopentag(name, attribs) {
                if (inContent && !inExclusion) {
                    element = tag2Element(name, attribs);
                    const mdResults = tags2Markdown(name, element);
                    if (markAsCode) {
                        mdResults.type = 'code';
                    }
                    // Mark start of code block
                    if (codeStartTags.some(codeTag => md.includes(codeTag))) {
                        if (!mdResults.tags[1].includes('[IMAGE]')) {
                            markAsCode = true;
                        }
                    }
                    // Start markdown element
                    if (mdArray.length > 0 && !markAsCode) {
                        if (mdArray[mdArray.length - 1].type !== mdResults.type && mdResults.type === 'code') {
                            mdArray[mdArray.length - 1].text += md;
                            md = '';
                        }
                    }
                    md += mdResults.tags[0];
                    // Store info for closing tag
                    tagsActive.push(mdResults.tags);
                    typesActive.push(mdResults.type);
                }
            },
            ontext(text) {
                if (text) {
                    if (inContent && !inExclusion) {
                        if (element) {
                            md += text;
                        }
                    }
                }
            },
            onclosetag() {
                if (inContent && !inExclusion) {
                    if (tagsActive.length > 0) {
                        // End markdown element
                        md += tagsActive[tagsActive.length - 1][1];
                        tagsActive.pop();
                        typesActive.pop();
                        if (md) {
                            const type = typesActive[typesActive.length - 1];
                            if (type === 'code' || markAsCode) {
                                // Mark end of code block
                                if (type === 'code' && markAsCode) {
                                    markAsCode = false;
                                }
                                md = md.replace(/&gt;/g, '>').replace(/&lt;/g, '<');
                                mdArray.push({ text: md, type: 'code' });
                            } else {
                                md = md.replace(/\$/g, '\\$');
                                mdArray.push({ text: md, type: 'markdown' });
                            }
                            md = '';
                        }
                        if (showHtml) {
                            mdArray.push({ text: '%%html\n' + showHtml, type: 'code' });
                            showHtml = '';
                        }
                    }
                    element = {};
                }
            }
        });
        parser.write(this.html);
        parser.done();

        // Add notebook dependencies (if any)
        if (this.name.includes('-mta')) {
            const name = this.name.replace('-mta', '')
            this.openCell('code', `%run ${name}.ipynb`)
        } else if (this.name.includes('-mtx')) {
            const name = this.name.replace('-mtx', '')
            this.openCell('code', `%run ${name}-mta.ipynb\n`)
        }

        // Write out notebook cells
        mdArray.forEach((cell, i) => {
            if (i === 0) {
                this.openCell(cell.type, cell.text);
            } else {
                cell.text = this.sanitizeNotebook(cell.text, cell.type);
                if (cell.text) {
                    // If same type as last cell
                    if (cell.type === mdArray[i - 1].type) {
                        if (cell.text.includes('%%writefile ')) {
                            this.openCell(cell.type, cell.text);
                        } else {
                            this.addToCell(cell.type, cell.text);
                        }
                    } else {
                        if (cell.type === 'code') {
                            this.openCell(cell.type, cell.text);
                        } else {
                            this.addToCell(cell.type, cell.text);
                        }
                    }
                }
            }
        })
        this.closeCell();
        return this;
    }

    openCell(type, content) {
        this.closeCell();
        let cell;
        content = content.trim().replace(/^[\n]+/, '');
        if (type === 'code') {
            content = content.replace(/^![\s]+/, '!')
            cell = {
                "cell_type": "code",
                "execution_count": null,
                "metadata": {},
                "outputs": [],
                "source": [content]
            }
        } else {
            cell = {
                "cell_type": "markdown",
                "metadata": {},
                "source": [content]
            }
        }
        this.cells.push(cell);
    }

    addToCell(type, content) {
        if (this.cells.length > 0) {
            // Can only append content to cell if previous cell content exists
            // (i.e. an open cell exists) and if the cell_type matches
            if (this.cells[this.cells.length - 1]['source'].length > 0 &&
                this.cells[this.cells.length - 1]['cell_type'] === type) {
                const source = this.cells[this.cells.length - 1]['source'];
                this.cells[this.cells.length - 1]['source'][source.length - 1] += content;
            } else {
                this.openCell(type, content);
            }
        }
    }

    closeCell() {
        if (this.cells.length > 0) {
            if (this.cells[this.cells.length - 1]['source'].length > 0) {
                const cell = this.cells[this.cells.length - 1];
                const source = cell['source']
                if (cell.cell_type === 'code') {
                    cell['source'][source.length - 1] = source[source.length - 1].trim().replace(/[\n]+$/g, '');
                }
                this.nb['cells'].push(cell);
                // Push empty cell to register closing of a cell
                this.cells.push({ "source": [] });
            }
        }
    }

}
