import os
import platform
import subprocess
from threading import Thread
from IPython import get_ipython
from IPython.core.magic import (Magics, magics_class, cell_magic, line_magic)

list_thread_cmds = [
    'cds watch',
    'cf login'
]

def start_thread_darwin(line):
    list_thread_darwin = [
        'printf \"#!/bin/bash',
        'function finish {',
        'rm notebook_thread.sh;'
        '}',
        'cd ' + os.getcwd(),
        line,
        'trap finish EXIT\" > notebook_thread.sh'
    ]
    thread_darwin = '\\n'.join(list_thread_darwin)
    thread_darwin += ' && chmod +x notebook_thread.sh'
    thread_darwin += ' && open -a Terminal notebook_thread.sh'
    return thread_darwin


def get_system_info(platform, line):
    system_info = { 'terminal': '', 'shell': '' }
    if platform == 'Windows':
        system_info['shell'] = 'cmd'
        system_info['terminal'] = 'start cmd /c ' + line
    elif platform == 'Linux':
        system_info['shell'] = 'bash'
        system_info['terminal'] = 'gnome-terminal -- ' + line
    elif platform == 'Darwin':
        system_info['shell'] = 'bash'
        # Store in tmp folder
        system_info['terminal'] = 'printf \"#!/bin/bash\\n' \
                                  'function finish {\\n' \
                                  'rm notebook_thread.sh;\\n' \
                                  '}\\n' \
                                  'cd ' + os.getcwd() + '\\n' + line + '\\n' \
                                  'trap finish EXIT\" > notebook_thread.sh' \
                                  ' && chmod +x notebook_thread.sh && open -a Terminal notebook_thread.sh'
        'printf \"{{{shell}}}\" > notebook_thread.sh' \
                                  ' && chmod +x notebook_thread.sh' \
                                  ' && open -a Terminal notebook_thread.sh'
    return system_info

@magics_class
class CustomMagics(Magics):

    # Modified %lsmagic to show up in vscode's notebook extension
    @line_magic
    def listmagic(self, line):
        line = line.strip()
        magics = str(get_ipython().run_line_magic('lsmagic', '',  _stack_depth=2))
        magics = magics.replace('\n', ' ')
        return magics

    # Helper function to also be able to replace variables when writing files
    @cell_magic
    def writetemplate(self, line, cell):
        "Writes file while inserting environment variables given as {var}"
        replaced = []
        filepath = line.strip('"')
        with open(filepath, 'w', encoding='utf8') as f:
            for k, v in sorted(os.environ.items()):
                template = '{' + k + '}'
                if '{' not in v:
                    template_value = '"' + v + '"'
                else:
                    template_value = v
                if template in cell:
                    cell = cell.replace(template, template_value)
                    replaced.append('{' + k + '}=' + template_value)
            f.write(cell)
        return 'Replaced ' + ', '.join(replaced) + '. Writing ' + line + '.'

get_ipython().register_magics(CustomMagics)

def new_thread_window(line):
    "Runs cds with native CLI, with function 'cds watch' being executed as a separate thread in new a terminal window."
    line = line.strip()
    system_info = get_system_info(platform.system(), line)
    cell_magic = system_info['terminal']
    # Starts a separate thread such that cmd does not block the notebook
    if cell_magic:
        def do_magic():
            get_ipython().run_cell_magic(system_info['shell'], '', cell_magic)
        Thread(target=do_magic).start()
        return 'Running ' + line + '...'
    else:
        return 'Please open a new terminal outside of the notebook and run: ' + line + '...'

def filter(*args):
    cmd = ' '.join(list(args))
    if cmd.lower().startswith(tuple(list_thread_cmds)):
        new_thread_window(cmd)
        print(cmd + ' started in new terminal window')
    else:
        cmd = ' '.join(list(args))
        try:
            output = subprocess.check_output(cmd, shell=True, stderr=subprocess.STDOUT)
            for line in output.splitlines():
                print(line.decode('utf-8'))
        except subprocess.CalledProcessError as e:
            for line in e.output.splitlines():
                if line.startswith(b'[ERROR]'):
                    print('\n')
                print(line.decode('utf-8'))
    return

get_ipython().system = filter

print('CAP magic loaded successfully - Have fun with your notebook!')