const TemplateBase = require('../templateBase');

const os = require('os');
const path = require('path');
const axios = require('axios');
const cp = require('child_process');

const commandUtil = require('../../util/commandUtil');
const term = require('../../../util/term');
const Notebook = require('./notebook');

const { URLS } = require('../../constants');
const { IS_MAC, IS_WIN, PYTHON_VENV_NAME } = require('../../constants');

const nbType = 'default';
const nbRequired = [];
const nbTypes = {
    'default': ['/docs/get-started/in-a-nutshell'],
    'mta': [
        '/docs/guides/databases#configure-hana',
        '/docs/advanced/deploy-to-cloud'
    ],
    'mtx': ['/docs/guides/multitenancy#nodejs-stack']
}

const REGEX_REDIRECT = /<meta\s+http-equiv\s*=\s*"refresh"\s+content\s*=\s*".*\s+url\s*=\s*(.*)\s*"/i;

module.exports = class NotebookTemplate extends TemplateBase {
    constructor(projectPath, generator) {
        super(projectPath, generator, __dirname);
        this.pythonCmd = null;
        this.pythonPckCmd = null;
        this.pythonPath = '';
        this.pythonPackages = '';
        this.pythonPathLib = '';
        this.hasVscode = false;
        this.hasJupyterlab = false;
        this.validPythonVenv = false;
        this.binPythonVenv = 'bin';
        this.libPythonVenv = 'lib';
        this.notebookEnv = '';
        this.notebookExtensions = '';
        this.hasNotebookExtension = false;
        this.scrapedCapire = {};
        this.nb_json = null;
        this.missingDependencies = [];
        this.logOutput = '';
    }

    async _collectMatchingCmds(matches) {
        let allCmds = '';
        for (const match of matches) {
            if (IS_WIN) {
                const matchReceived = await this._tryCatchReturn({
                    error: null,
                    cmd: `where`,
                    args: [`${match}*`]
                })
                if (matchReceived) {
                    allCmds += matchReceived;
                }
            } else {
                let compgenCmd = `compgen -c ${match}`;
                if (IS_MAC) {
                    compgenCmd = `compgen -ac | grep ${match}`
                }
                const matchReceived = await this._tryCatchReturn({
                    error: null,
                    cmd: '/bin/bash',
                    args: ['-c', `${compgenCmd}`]
                })
                if (matchReceived) {
                    allCmds += matchReceived;
                }
            }
        }
        const cmds = [];
        for (const cmd of allCmds.split('\n')) {
            cmds.push(path.basename(cmd.trim()))
        }
        return cmds
    }

    async _pythonCmdCheck() {
        const pythonAliases = await this._collectMatchingCmds(['python']);
        for (const pythonAlias of pythonAliases) {
            try {
                let pythonVersion = await commandUtil.spawnCommand(pythonAlias, ['--version'], {
                    cwd: this.projectPath
                }, undefined, true);
                pythonVersion = pythonVersion.replace('Python ', '');
                if (parseFloat(pythonVersion) >= parseFloat('3.8.5')) {
                    this.pythonCmd = pythonAlias;
                    break;
                }
            } catch (err) {
                // Do nothing
            }
        }
        if (this.pythonCmd === null) {
            this.missingDependencies.push('Python (>=v3.8.5):\n' +
                term.warn(`  ${URLS.PYTHON}\n`));
            if (!IS_WIN) {
                this.logger.log(`When using the configure script, you must add ${term.bold('--with-ensurepip=install')}`)
            }
        }
    }

    async _pythonPckCmdCheck() {
        const pipAliases = await this._collectMatchingCmds(['pip', 'conda']);
        for (const pipAlias of pipAliases) {
            try {
                await commandUtil.spawnCommand(pipAlias, ['--version'], {
                    cwd: this.projectPath
                }, undefined);
                this.pythonPckCmd = pipAlias;
                break;
            } catch (err) {
                // Do nothing
            }
        }
        if (this.pythonPckCmd === null) {
            try {
                await commandUtil.spawnCommand('conda', ['info'], {
                    cwd: this.projectPath
                }, undefined, true);
                this.pythonPckCmd = 'conda';
            } catch (err) {
                this.missingDependencies.push(
                    'Python package manager:\n' +
                    term.warn(`  ${URLS.PYTHON_PIP}`)
                );
            }
        }
    }

    async _pythonPcksCheck() {
        const argPckCmd = 'list';
        if (this.pythonPckCmd !== null) {
            try {
                if (!this.pythonPackages) {
                    this.pythonPackages = await commandUtil.spawnCommand(this.pythonPckCmd, [argPckCmd], {
                        cwd: this.projectPath
                    }, undefined, true);
                }
            } catch (err) {
                // Do nothing
            }
        }
        if (this.pythonPackages.includes('jupyterlab')) {
            this.hasJupyterlab = true;
        }
    }

    async _notebookViewerCheck() {
        try {
            await commandUtil.spawnCommand('code', ['--version'], {
                cwd: this.projectPath
            });
            this.hasVscode = true;
        } catch (err) {
            this.logger.log(`Consider installing vscode: ${URLS.VSCODE}`)
        }
        if (this.hasVscode) {
            this.notebookExtensions = await commandUtil.spawnCommand('code',
                ['--list-extensions', '--category', 'notebooks'], {
                cwd: this.projectPath
            }, undefined, true);
            if (this.notebookExtensions && this.notebookExtensions.includes('ms-python.python')) {
                this.hasNotebookExtension = true;
            }
            if (!this.hasNotebookExtension) {
                this.missingDependencies.push('No notebook viewer found!\n' +
                    term.info(`Consider installing the VS Code Python extension:\n
                         'ms-python.python': ${URLS.VSCODE_NBVIEWER}\n`));
            }
        }
    }

    _getNotebookEnv() {
        this.notebookEnv = path.join(os.homedir(), PYTHON_VENV_NAME);
        let cmd;
        if (IS_WIN) {
            cmd = 'where';
        } else {
            cmd = 'which';
        }
        this.pythonPath = cp.execSync(`${cmd} ${this.pythonCmd}`).toString();
    }

    async _tryCatch(task) {
        try {
            await commandUtil.spawnCommand(
                task.cmd,
                task.args, {
                cwd: this.projectPath
            }, undefined, true);
        } catch (err) {
            if (task.error) {
                throw new Error(task.error);
            }
        }
    }

    async _tryCatchReturn(task) {
        try {
            const result = await commandUtil.spawnCommand(
                task.cmd,
                task.args, {
                cwd: this.projectPath
            }, undefined, true);
            return result;
        } catch (err) {
            if (task.error) {
                throw new Error(task.error);
            }
        }
    }

    async _createPythonVenv(pythonPackagesReq) {
        await this._tryCatch({
            error: "Failed to initialize virtualenv.\n" +
                "If you get the error [ ... 'ensurepip', '--upgrade', '--default-pip']', please install ensurepip via:\n" +
                `${term.bold('sudo apt-get install ' + this.pythonCmd + '-venv')}`,
            cmd: `${this.pythonCmd}`,
            args: ['-m', 'venv', `${this.notebookEnv}`]
        })
        if (IS_WIN) {
            await this._tryCatch({
                error: "Failed to prepare virtualenv",
                cmd: `"${path.join(this.notebookEnv, this.binPythonVenv, 'activate')} && ` +
                    `pip install ${pythonPackagesReq.join(' ')} && ` +
                    `${path.join(this.notebookEnv, this.binPythonVenv, 'ipython')} kernel install --user --name=${PYTHON_VENV_NAME} && ` +
                    `deactivate"`,
                args: []
            })
        } else {
            await this._tryCatch({
                error: "Failed to prepare virtualenv",
                cmd: '/bin/sh',
                args: ['-c', `. ${path.join(this.notebookEnv, this.binPythonVenv, 'activate')}
                pip install ${pythonPackagesReq.join(' ')}
                ${path.join(this.notebookEnv, this.binPythonVenv, 'ipython')} kernel install --user --name=${PYTHON_VENV_NAME}
                deactivate`]
            })
        }
    }

    async _checkPythonVenv(pythonPackagesReq) {
        // Check if venv exists
        const pythonVenvPath = await this.fsUtil.pathExists(this.notebookEnv);
        if (pythonVenvPath) {
            if (IS_WIN) {
                this.pythonPathLib = path.join(this.notebookEnv, this.libPythonVenv, 'site-packages');
            } else {
                this.pythonPathLib = path.join(this.notebookEnv, this.libPythonVenv, 'python*', 'site-packages');
            }
            // Check if required packages exist
            for (const pck of pythonPackagesReq) {
                const pckExists = await this.fsUtil.pathExists(this.pythonPathLib, pck);
                if (!pckExists) {
                    return false;
                }
            }
            // Check if required scripts exist
            let pythonScriptsReq;
            if (IS_WIN) {
                pythonScriptsReq = ['python.exe', 'ipython.exe', 'jupyter-kernel.exe'];
            } else {
                pythonScriptsReq = ['python', 'ipython', 'jupyter-kernel'];
            }
            for (const pck of pythonScriptsReq) {
                const pckExists = await this.fsUtil.pathExists(this.pythonPathLib, pck);
                if (!pckExists) {
                    return false;
                }
            }
        } else {
            return false
        }
        return true;
    }

    async _url2Html(contentUrl) {
        const response = await axios.get(contentUrl, {
            headers: {
                'Access-Control-Allow-Origin': '*'
            }, 'timeout': 20000
        });
        const match = REGEX_REDIRECT.exec(response.data);
        if (match && match[1]) {
            const newContentUrl = new URL(contentUrl);
            const newUrl = new URL(match[1], newContentUrl.origin);
            this._url2Html(newUrl)
        } else {
            return response.data;
        }
    }

    async _collectHtmlPages(nbReq) {
        if (!this.scrapedCapire[nbReq]) {
            let pageCollection = '';
            for (let p = 0; p < nbTypes[nbReq].length; p++) {
                const page = nbTypes[nbReq][p];
                try {
                    const html = await this._url2Html(URLS.CAPIRE + page);
                    if (!pageCollection) {
                        pageCollection = html;
                    } else {
                        pageCollection += html;
                    }
                } catch (err) {
                    // Do nothing
                }
            }
            this.scrapedCapire[nbReq] = pageCollection;
        }
    }

    async _notebookInit(projectName) {
        // Create new notebook, overwrite if already exists
        await this.templateUtil.copyFiles('.', this.projectPath, { name: projectName, cap: URLS.CAPIRE }, true);
        this.nb_json = path.resolve('.', this.projectPath, `${projectName}.ipynb`);
        const exists = await this.fsUtil.pathExists(this.nb_json);
        const nb = exists ? await this.fsUtil.readJSON(this.nb_json) : {};
        return nb;
    }

    async _notebookWriteFromComponents(type) {
        if (type === 'mta') {
            nbRequired.push('default')
        } else if (type === 'mtx') {
            nbRequired.push('default')
            nbRequired.push('mta')
        }
        nbRequired.push(type)

        for (let n = 0; n < nbRequired.length; n++) {
            const nbReq = nbRequired[n];

            // Get notebook name
            let projectName = `${this.projectName}`
            if (nbReq !== 'default') {
                projectName = `${this.projectName}-${nbReq}`
            }
            await this._collectHtmlPages(nbReq);
            const nb = await this._notebookInit(projectName);

            // Add cap magic
            const stringPython = await this.fsUtil.readFile(path.join(__dirname, 'cap_magic.py'), 'UTF-8');
            nb['metadata']['cap_magic'] = stringPython;

            // Generate notebook
            this.logger.debug(`  writing ${type} notebook...`)
            const notebook = new Notebook({ name: projectName, nb: nb, html: this.scrapedCapire[nbReq], url: URLS.CAPIRE, route: nbTypes[nbReq][0] });
            await this.fsUtil.writeJSON(this.nb_json, notebook.nb);
        }
    }

    async checkEnabled() {
        return true;
    }

    async run() {

        // REQUIRED: Python [python or python3]
        if (!this.pythonCmd) {
            await this._pythonCmdCheck()
        }

        // REQUIRED: Python package manager
        if (!this.pythonPckCmd) {
            await this._pythonPckCmdCheck()
        }

        // OPTIONAL: JupyterLab viewer in python packages
        if (!this.hasJupyterlab) {
            await this._pythonPcksCheck()
        }

        // OPTIONAL: Jupyter Notebook viewer in VS Code extensions
        if (!this.hasVscode && !this.hasNotebookExtension) {
            await this._notebookViewerCheck()
        }

        // If missing dependencies, throw error
        if (this.missingDependencies.length > 0) {
            let error = '\nYou are missing ' + this.missingDependencies.length + ' notebook dependencies!\n' +
                'Please install the following components (in order!) and rerun your cds command:\n\n'
            for (let i = 0; i < this.missingDependencies.length; i++) {
                error += '(' + (i + 1) + ') ' + this.missingDependencies[i] + '\n';
            }
            throw new Error(error);
        } else {
            if (IS_WIN) {
                this.binPythonVenv = 'Scripts';
                this.libPythonVenv = 'Lib';
            }
            if (!this.pythonPath) {
                this._getNotebookEnv();
            }
            // If not exists, install virtualenv with required packages
            const pythonPackagesReq = ['ipykernel', 'notebook'];
            if (!this.validPythonVenv) {
                this.validPythonVenv = await this._checkPythonVenv(pythonPackagesReq);
                if (!this.validPythonVenv) {
                    await this._createPythonVenv(pythonPackagesReq);
                }
            }
            // Generate notebook from components
            await this._notebookWriteFromComponents(nbType);
        }
    }

    async finalize() {
        this.logOutput = [' '];
        if (this.hasVscode && this.hasNotebookExtension) {
            this.logOutput.push(`To view the notebook in VS Code:`);
            this.logOutput.push(`\t1. ${term.info('Ctrl + Click')} the following link: ${term.info(`${this.nb_json}`)}`);
            this.logOutput.push(`\t2. Make sure to ${term.info('Trust')} the notebook in the popup window to enable markdown and code execution`);
            this.logOutput.push(`\t3. Run the notebook`);
            this.logOutput.push('');
        }
        if (this.pythonPackages.includes('notebook') && this.hasJupyterlab) {
            this.logOutput.push(`To view the notebook in JupyterLab:`);
            this.logOutput.push(`\t1. Open with JupyterLab: ${term.info(`python -m jupyterlab ${path.relative(process.cwd(), this.nb_json)}`)}`);
            this.logOutput.push(`\t2. Run the notebook`);
            this.logOutput.push('');
        }
        this.logOutput.push(`To view the notebook in your browser:`);
        this.logOutput.push(`\t1. Open with Jupyter: ${term.info(path.join(this.notebookEnv, this.binPythonVenv, 'jupyter') +
            ' notebook ' + path.relative(process.cwd(), this.nb_json))}`);
        this.logOutput.push(`\t2. Run the notebook`);
        this.logOutput.push('');

        for (const line of this.logOutput) {
            this.logger.log(line);
        }
    }
}
