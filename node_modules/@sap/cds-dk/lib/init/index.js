const path = require('path');

const { defaultLogger } = require('./util/logger');
const FsUtil = require('./util/fsUtil');
const term = require('../util/term');
const Spinner = require('./util/spinner');

const CMD_INIT = 'init';
const CMD_ADD = 'add';

const { OPTIONS_PRIORITY,
    OPTION_HANA, OPTION_JAVA, OPTION_MTA, OPTION_MTX, OPTION_NODEJS,
    OPTION_PIPELINE, OPTION_SAMPLES, OPTION_CF_MANIFEST, OPTION_LINT,
    OPTION_LINT_CUSTOM, PROJECT_FILES, REGEX_PROJECT_NAME } = require('./constants');

module.exports = class CDSGenerator {
    constructor(fsUtil, logger) {
        this.fsUtil = fsUtil || new FsUtil();
        this.logger = logger || defaultLogger;

        this.uiConfig = [
            {
                title: `Project Name`,
                description: `Enter your project name.`,
                default: '',
                target: 'projectName',
                validate: async (value) => {
                    try {
                        await this._validateProjectName(value);
                        await this._validateProjectFolder(path.join(process.cwd(), value), process.cwd());

                        return true;
                    } catch (err) {
                        return err.message;
                    }
                },
                guiOptions: {
                    hint: 'This name is restricted to certain characters. A valid project name is compatible across platforms.',
                    mandatory: true
                }
            },
            {
                title: `Type`,
                description: `Select your runtime.`,
                default: OPTION_NODEJS,
                choices: [
                    { name: 'Node.js', value: OPTION_NODEJS },
                    { name: 'Java', value: OPTION_JAVA }
                ],
                multiple: false,
                target: 'add',
                guiOptions: {
                    hint: `The preferred runtime can't be changed afterwards. To use a different runtime, create a new project.`,
                    mandatory: true
                }
            },
            {
                title: `Features`,
                description: `Add features to your project.`,
                default: '',
                choices: [
                    { name: 'CI/CD Pipeline Integration', value: OPTION_PIPELINE },
                    { name: 'Configuration for SAP HANA Deployment', value: OPTION_HANA },
                    { name: 'MTA based SAP Business Technology Platform Deployment', value: OPTION_MTA },
                    // { name: 'Multitenancy', value: OPTION_MTX },
                    // { name: 'Jupyter base CAP Notebook', value: OPTION_NOTEBOOK },
                    { name: `Cloud Foundry native Deployment`, value: OPTION_CF_MANIFEST },
                    { name: `CDS Linter`, value: OPTION_LINT },
                    { name: `CDS Linter Custom`, value: OPTION_LINT_CUSTOM }
                ],
                multiple: true,
                target: 'add',
                guiOptions: {
                    hint: `Choose any combination of features enriching the capabilities of your project. You can also add features later with ${term.bold('cds add')}`
                }
            },
            {
                title: `Samples`,
                description: `Add sample content to your project.`,
                default: '',
                choices: [
                    { name: 'Basic Sample Files', value: OPTION_SAMPLES }
                ],
                multiple: true,
                target: 'add',
                guiOptions: {
                    hint: 'Speed up your ramp-up phase with some sample files in your project.'
                }
            }
        ]

        // legacy handling for generator-cap-project < 3.0
        // does not contain OPTION_NODJES since old Yeoman generator
        // cannot handle types correctly
        this.config = {
            add: {
                title: `Features`,
                description: `Select the features for the new project.`,
                default: '',
                // choices: OPTIONS_PRIORITY.filter((currOption) => currOption !== OPTION_NODEJS),
                choices: [
                    OPTION_JAVA,
                    OPTION_HANA,
                    OPTION_PIPELINE,
                    OPTION_CF_MANIFEST,
                    OPTION_MTA,
                    OPTION_SAMPLES
                ],
                multiple: true,
                promptOrder: 10 // used to identify ui prompts
            },
            force: {
                default: false
            }
        }
    }

    /**
     * @param {string} templates, comma separated list of templates, no blanks
     * @param {any} options, additional options
     */
    async addCmd(templates, options = {}) {
        options._cmd = CMD_ADD;
        options.add = templates;

        this._initialize(null, options);
        this._greetings(options._cmd);

        if (!(await this._findProjectFile(this.projectPath))) {
            throw new Error(`The current folder doesn't seem to contain a project. None of the following files found: ${PROJECT_FILES.join(', ')}.`);
        }

        if (options.add.has(OPTION_JAVA) || options.add.has(OPTION_NODEJS)) {
            throw new Error(`You can't change the type of an existing project.`);
        }

        if (options.add.has(OPTION_MTX)) {
            throw new Error(`You can't add multitenancy to an existing project.`);
        }

        await this._process(options);
        await this.stepEnd(options);
    }

    /**
     * @param {string} projectName, the project name
     * @param {any} options, additional options
     */
    async initCmd(projectName, options = {}) {
        await this.stepInit(projectName, options);
        await this.stepEnd();
    }

    async stepInit(projectName, options = {}) {
        options._cmd = CMD_INIT;

        this._initialize(projectName, options);
        this._greetings(options._cmd);

        await this._process();
    }

    async _findProjectFile(projectPath) {
        for (const file of PROJECT_FILES) {
            if (await this.fsUtil.pathExists(path.join(projectPath, file))) {
                return file;
            }
        }

        return null;
    }

    _initialize(projectName, options = {}) {
        // deprecated, only for compatibility
        if (options.verbose) {
            this.logger.warn(`Parameter 'verbose' is no longer supported. Use environment variable 'DEBUG=true' to obtain detailed output.`);
        }

        this.cwd = options.cwd || process.cwd();
        this.projectPath = path.resolve(this.cwd, projectName || '.');
        this.projectName = path.basename(this.projectPath);

        this.options = options;
        this._cleanupOptions();
    }

    _greetings(cmd) {
        switch (cmd) {
            case CMD_INIT: {
                const relativeProjectPath = path.relative(this.cwd, this.projectPath);
                const folderName = (relativeProjectPath ? `.${path.sep}${relativeProjectPath}` : 'current folder');
                this.logger.log(`creating new project in ${folderName}`);
                break;
            }

            case CMD_ADD:
                this.logger.log(`adding feature(s) to project in current folder`);
                break;

            default:
        }

        if (this.options.force) {
            this.logger.log(`using '--force' ... existing files will be overwritten...!`);
        }
    }

    async _process() {
        this.logger.debug(`Project path: ${this.projectPath}`);

        await this._validateOptions();
        await this._fillTemplateList();

        for (const template of this.templateList) {
            const msg = `adding feature '${template.name}'...`;
            if (this.logger.isDebug) {
                this.logger.log(msg);
                await template.run();
            } else {
                const spinner = new Spinner(this.logger);
                await spinner.run(msg, async () => { // NOSONAR
                    return template.run();
                });
            }
        }

        this.logger.log(`done.`);
        this.logger.log();
    }

    _createTemplate(clazz) {
        try {
            if (clazz === OPTION_LINT_CUSTOM) {
                clazz = OPTION_LINT
            }
            const TemplateClass = require(`./template/${clazz}`);
            return new TemplateClass(this.projectPath, this);
        } catch (err) {
            throw new Error(`feature '${clazz}' not found. ${err}`);
        }
    }

    async _fillTemplateList() {
        const templates = new Map();
        for (const option of this.options.add) {
            if (!templates.has(option)) {
                const template = this._createTemplate(option);

                if (await template.checkEnabled()) {
                    this.logger.debug(`Adding feature '${template.name}'`);

                    templates.set(option, template);
                    const deps = await template.getDependencies();
                    if (deps) {
                        deps.forEach(this.options.add.add, this.options.add)
                    }
                }
            }
        }

        this.templateList = Array.from(templates.entries()).sort((a, b) => {
            return OPTIONS_PRIORITY.indexOf(a[0]) - OPTIONS_PRIORITY.indexOf(b[0]);
        }).map((entry) => entry[1]);

        // check debug to avoid lengthy computation when not in debug mode
        this.logger.isDebug && this.logger.debug(`Features: ${this.templateList.map((obj) => {
            return obj.name;
        }).join(', ')}`);
    }

    async stepEnd() {
        this.logger.isDebug && this._showFiles();

        for (const template of this.templateList) {
            await template.finalize();
        }
    }

    _showFiles() {
        const files = this.fsUtil.getTouchedFiles();
        if (files && files.length > 0) {
            this.logger.log(`added / changed files`);
            for (const file of files) {
                this.logger.log(file);
            }
            this.logger.log();
        }
    }

    _cleanupOptions() {
        let tokens = [];

        if (typeof this.options.add === 'string') {
            tokens = this.options.add.split(/[,\s]/);

        } else if (Array.isArray(this.options.add)) {
            tokens = this.options.add

        } else if (this.options.add instanceof Set) {
            tokens = [...this.options.add];
        }

        const trimmedTokens = tokens.map((token) => {
            return token.trim();
        }).filter((token) => {
            return !!token;
        });

        // set is ordered ... always
        this.options.add = new Set(trimmedTokens);

        if (this.options._cmd === CMD_INIT && !this.options.add.has(OPTION_JAVA)) {
            this.options.add.add(OPTION_NODEJS);
        }
    }

    async _validateOptions() {
        if (this.options.force) {
            return;
        }

        if (this.options._cmd === CMD_INIT) {
            await this._validateProjectName(this.projectName);
            await this._validateProjectFolder(this.projectPath, this.cwd);
        }
    }

    async _validateProjectName(projectName) {
        if (!projectName) {
            throw new Error('Specify a project name.');
        }

        // remove duplicates by using a set
        const invalidChars = new Set(projectName.match(REGEX_PROJECT_NAME));
        switch (invalidChars.size) {
            case 0:
                break;
            case 1:
                throw new Error(`Project name ${projectName} contains an invalid character (${[...invalidChars].join(', ')}). Specify a different project name.`);
            default:
                throw new Error(`Project name ${projectName} contains invalid characters (${[...invalidChars].join(', ')}). Specify a different project name.`);
        }
    }

    async _validateProjectFolder(projectPath, cwd) {
        const existingProjectFile = await this._findProjectFile(projectPath);
        if (existingProjectFile) {
            let message;
            if (cwd === projectPath) {
                message = `You seem to be working in a project which is already initialized. Use ${term.bold('cds add')} to add more features.`;
            } else {
                message = `You seem to be trying to initialize an existing project. Use a different project name instead.`;
            }
            throw new Error(`${message}\nDetails: File '${existingProjectFile}' exists in the project folder which indicates an existing project. Use ${term.bold('cds add')} to add more features.`);
        }
    }
}
