const os = require("os");
const fs = require("fs");
const cp = require("child_process");
const path = require("path");
const yaml = require("@sap/cds-foss")("yaml");
const term = require("../util/term");

const IS_WIN = os.platform() === "win32";

const REGEX_OPTIONS = /--[a-z,a-z-]+\s/gm;
const REGEX_SHORTCUTS = /\s-[a-zA-Z]+/gm;

const ERR_MISSING_ESLINT =
  `ESLint executable 'eslint' not found!\n\n` +
  `   See instructions on how to install ESLint at:\n` +
  `   ${term.warn("https://eslint.org/docs/user-guide/getting-started")}\n`;
const ERR_VERSION_ESLINT =
  `ESLint v>=6.0.0 required!\n\n` +
  `   Make sure to update and check for any breaking changes:\n` +
  `   ${term.warn("https://eslint.org/docs/user-guide/migrating-to-6.0.0")}\n`;
const ERR_MISSING_CONFIG =
  `ESLint couldn't find a configuration file!\n\n` +
  `   Set up your project for proper linting by running:\n` +
  `   ${term.warn("cds add lint")}\n`;
const ERR_INVALID_EXTENDS = `Missing valid "extends" entry: 'plugin:@sap/cds/...'\n`;

class Linter {
  constructor() {
    this.cdsdkPath = path.join(__dirname, "../..");
    this.eslintCmd = "";
    this.eslintVersion = "";
    this.eslintPluginPath = "";
    this.cdsdkPath = path.join(__dirname, "../..");
    this.configPath = "";
    this.projectPath = "";
    this.eslintConfig = null;
    this.eslintRules = null;
    this.hasEslintCDSPlugin = false;
    this.isValid = false;
    this._getEslintHelp = this._getEslintHelp.bind(this);
    this._getConfigPath = this._getConfigPath.bind(this);
    this._checkEslintCmd = this._checkEslintCmd.bind(this);
    this._hasEslintCDSPlugin = this._hasEslintCDSPlugin.bind(this);
    this._readConfigContents = this._readConfigContents.bind(this);
    this._checkEslintConfig = this._checkEslintConfig.bind(this);
    this._collectUserInput = this._collectUserInput.bind(this);
    this._genDocs = this._genDocs.bind(this);
    this.init = this.init.bind(this);
    this.lint = this.lint.bind(this);
  }

  /**
   * This function must be run synchronously as it is required
   * by Linter.init()!
   * @returns ESLint 'help' output
   */
  _getEslintHelp() {
    let eslintHelp;
    this._checkEslintCmd();
    try {
      eslintHelp = cp
        .execSync(`${this.eslintCmd} -h`, {
          cwd: process.cwd(),
          shell: IS_WIN, // for windows only,
          stdio: "pipe",
        })
        .toString();
    } catch (err) {
      throw new Error(ERR_MISSING_ESLINT);
    }
    let eslintOpts = eslintHelp.split("\n");
    let cdslintCmd = eslintOpts[0].replace("eslint", "*cds lint*");
    eslintOpts[0] = `
    # SYNOPSIS

        ${cdslintCmd}

        Runs environment checks and/or checks the specified models
        based on the ESLint framework

    # OPTIONS`;
    return `${eslintOpts.join("\n    ")}\n`;
  }

  _getConfigPath(currentDir = ".") {
    // Configuration files (in order or precedence)
    // See: https://eslint.org/docs/user-guide/configuring#configuration-file-formats
    const configFiles = [
      ".eslintrc.js",
      ".eslintrc.cjs",
      ".eslintrc.yaml",
      ".eslintrc.yml",
      ".eslintrc.json",
      ".eslintrc",
      "package.json",
    ];
    let configDir = path.resolve(currentDir);
    while (configDir !== path.resolve(configDir, "..")) {
      for (let i = 0; i < configFiles.length; i++) {
        const configPath = path.join(configDir, configFiles[i]);
        if (fs.existsSync(configPath) && fs.statSync(configPath).isFile()) {
          return configPath;
        }
      }
      configDir = path.join(configDir, "..");
    }
    throw new Error(ERR_MISSING_CONFIG);
  }

  _checkEslintCmd(paths = this.cdsdkPath, throwErr = true) {
    let eslintCmd, eslintVersion;
    if (!this.eslintCmd || !this.eslintVersion) {
      try {
        const eslintPath = require.resolve("eslint/package.json", {
          paths: [paths],
        });
        const eslintPackageJson = require(eslintPath);
        eslintVersion = eslintPackageJson.version;
        let eslintScript = path.resolve(
          eslintPath,
          "..",
          eslintPackageJson.bin.eslint
        );
        if (IS_WIN) {
          eslintScript = `"${eslintScript}"`;
        }
        eslintCmd = `node ${eslintScript}`;
      } catch (err) {
        if (throwErr) {
          throw new Error(ERR_MISSING_ESLINT);
        } else {
          return false;
        }
      }
      this.eslintCmd = eslintCmd;
      this.eslintVersion = eslintVersion;
    } else if (this.eslintCmd && this.eslintVersion) {
      if (this.eslintVersion < "6") {
        throw new Error(ERR_VERSION_ESLINT);
      }
    }
    return true;
  }

  _hasEslintCDSPlugin(projectPath) {
    try {
      const pluginPath = require.resolve("@sap/eslint-plugin-cds", {
        paths: [projectPath],
      });
      this.eslintPluginPath = pluginPath;
      return true;
    } catch (error) {
      const pluginPath = require.resolve("@sap/eslint-plugin-cds", {
        paths: [this.cdsdkPath],
      });
      this.eslintPluginPath = pluginPath;
      return false;
    }
  }

  _readConfigContents(configPath) {
    let config;
    let configFile = path.basename(configPath);
    switch (configFile) {
      case ".eslintrc.js":
      case ".eslintrc.cjs":
        config = require(configPath);
        break;
      case ".eslintrc.yaml":
      case ".eslintrc.yml":
        config = yaml.parse(fs.readFileSync(configPath, "utf8"));
        break;
      case ".eslintrc.json":
      case ".eslintrc":
      case "package.json":
        config = JSON.parse(fs.readFileSync(configPath, "utf8"));
        break;
      default:
        break;
    }
    return config;
  }

  _checkEslintConfig(configPath, options = []) {
    let eslintConfig = this.eslintConfig;
    if (!this.eslintConfig) {
      eslintConfig = this._readConfigContents(configPath);
      this.eslintConfig = eslintConfig;
    } else {
      eslintConfig = this.eslintConfig;
    }
    if (path.basename(configPath) === "package.json") {
      eslintConfig = this.eslintConfig["eslintConfig"];
    }
    if (typeof eslintConfig === "object") {
      if (options.includes("extends")) {
        if (
          !eslintConfig.extends ||
          (!eslintConfig.extends.includes(`plugin:@sap/cds/recommended`) &&
            !eslintConfig.extends.includes(`plugin:@sap/cds/model`) &&
            !eslintConfig.extends.includes(`plugin:@sap/cds/environment`))
        ) {
          throw new Error(ERR_INVALID_EXTENDS);
        }
      }
      if (options.includes("rules")) {
        if (eslintConfig.rules) {
          this.eslintRules = [];
          Object.keys(eslintConfig.rules).forEach((rule) => {
            this.eslintRules.push({
              name: rule,
              severity: eslintConfig.rules[rule],
            });
          });
        }
      }
      return true;
    }
  }

  _collectUserInput(args, flag, props) {
    const propIndex = args.indexOf(flag);
    if (propIndex !== -1) {
      let propsUser = args[propIndex + 1].split(",");
      propsUser.array.forEach((prop) => {
        prop = prop.trim();
        if (props.indexOf(prop) === -1) {
          props.push(args[propIndex + 1]);
        }
      });
      args.splice(props, 2);
    }
    return props;
  }

  _hasCustomCDSRules(rulesDir) {
    try {
      const rules = fs.readdirSync(rulesDir);
      if (rules.length > 0) {
        for (let rule in this.eslintConfig.rules) {
          if (rules.includes(`${rule}.js`)) {
            return true;
          }
        }
      }
    } catch (err) {
      // Do nothing
    }
    return false;
  }

  _genDocs(projectPath) {
    let mdRule, mdRuleSources, mdRuleContents;
    const testPath = path.join(projectPath, ".eslint/tests");
    const rulePath = path.join(projectPath, ".eslint/rules");
    const docsPath = path.join(projectPath, ".eslint/docs");
    const ruleDocsPath = path.join(docsPath, "Rules.md");
    const ruleListDocsPath = path.join(docsPath, "RuleList.md");
    const ruleDict = {};

    function getKeyFromMeta(text, key) {
      const regexQuote = new RegExp(`${key}:[\\s]+[\\', \\\`, \\"]`, "gm");
      const matchQuote = regexQuote.exec(text);
      if (matchQuote) {
        const quote = matchQuote[0].slice(-1);
        const exprStart = `${key}:[\\s]+\\${quote}`;
        const exprEnd = `(\\${quote},?)`;
        const regexKey = new RegExp(`${exprStart}[\\s\\S]*?${exprEnd}`, "gm");
        const matchKey = regexKey.exec(text);
        if (matchKey) {
          const regexStart = new RegExp(`${exprStart}`, "gm");
          const regexEnd = new RegExp(`${exprEnd}`, "gm");
          return matchKey[0]
            .replace(regexStart, "")
            .replace(regexEnd, "")
            .replace("fixable:", "")
            .trim();
        } else {
          return "";
        }
      } else {
        return "";
      }
    }

    function getKeyFromTest(text, key) {
      let dissallowPrefix = "";
      if (key === "valid") {
        dissallowPrefix = "[^n]";
      }
      const exprStart = `${dissallowPrefix}${key}:[\\s]+\\[[\\s\\n]+{[\\s\\n]+code:[\\s\\n]+`;
      const regexTestKey = new RegExp(`${exprStart}[\\', \\\`, \\"]`, "gm");
      const matchTestKey = regexTestKey.exec(text);
      if (matchTestKey) {
        const quote = matchTestKey[0].slice(-1);
        const exprStart = `${dissallowPrefix}${key}:[\\s]+\\[[\\s\\n]+{[\\s\\n]+code:[\\s\\n]+`;
        const regexStart = new RegExp(exprStart, "gm");
        const regexCode = new RegExp(
          `${exprStart}${quote}[\\s\\S]*?(\\${quote},?)`,
          "gm"
        );
        const matchCode = regexCode.exec(text);
        const code = matchCode[0].replace(regexStart, "");
        const regex = new RegExp(`${quote},`, "gm");
        const regex2 = new RegExp(`${quote}`, "gm");
        return code.replace(regex, "").replace(regex2, "");
      } else {
        return "";
      }
    }

    function genMdRules(release, table = true) {
      let version = "latest";
      if (release) {
        version = release;
      }
      let mdRules = `# @sap/eslint-plugin-cds [${version}]\n\n`;
      if (table) {
        Object.entries(ruleDict).forEach(([category, rules]) => {
          mdRules += `## Category: ${category}\n\n`;
          mdRules += "<table>";
          mdRules += "<tr><th>Rule</th><th>Fixable</th><th>Version</th></tr>";
          rules.forEach(function (rule) {
            mdRules += `<tr><td><a href="./Rules.md#rule-${rule.name}">${rule.name}</a></td><td>${rule.fix}</td><td>${rule.version}</td></tr>`;
          });
          mdRules += "</table>\n\n<br>\n\n";
        });
      }
      return mdRules;
    }

    const mdRulesCur = fs.readFileSync(ruleDocsPath, "utf8");
    const mdRuleListCur = fs.readFileSync(ruleListDocsPath, "utf8");
    fs.readdirSync(rulePath).filter(function (file) {
      if (path.extname(file).toLowerCase() === ".js") {
        const rule = path.basename(file).replace(path.extname(file), "");
        const ruleTestPath = path.join(testPath, `${rule}.test.js`);

        // Get rule meta information
        const ruleMeta = fs.readFileSync(path.join(rulePath, file), "utf8");
        const details = getKeyFromMeta(ruleMeta, "description");
        const category = getKeyFromMeta(ruleMeta, "category");
        const fixable = getKeyFromMeta(ruleMeta, "fixable");
        let isFixable = "";
        if (["code", "whitespace"].includes(fixable)) {
          isFixable = ":wrench:";
        }
        const version = getKeyFromMeta(ruleMeta, "version");

        // Get rule valid/invalid tests
        mdRule = "";
        if (fs.existsSync(ruleTestPath)) {
          const ruleTest = fs.readFileSync(ruleTestPath, "utf8");
          const valid = getKeyFromTest(ruleTest, "valid");
          const invalid = getKeyFromTest(ruleTest, "invalid");

          mdRule +=
            `<span>:heavy_check_mark:&nbsp;&nbsp; Example of ` +
            `<font style="color:green">correct</font> ` +
            `code for this rule:</span>\n\n\`\`\`\n${valid}\n\`\`\`\n\n`;
          mdRule +=
            `<span>:x:&nbsp;&nbsp; Example of ` +
            `<font style="color:red">incorrect</font> ` +
            `code for this rule:</span>\n\n\`\`\`\n${invalid}\n\`\`\``;
        }

        mdRuleContents = `## Rule: ${rule}\n`;
        mdRuleContents += `<span class='label shifted'>${category}</span>\n\n`;
        mdRuleContents += `### Rule Details\n${details}\n\n`;
        if (mdRule) {
          mdRuleContents += `### Examples\n${mdRule}\n\n`;
        }
        mdRuleContents += `### Version\nThis rule was introduced in \`@sap/eslint-plugin-cds ${version}\`.\n\n`;
        mdRuleSources = `### Resources\n[Rule & Documentation source](${path.relative(
          docsPath,
          path.join(rulePath, `${rule}.js`)
        )})\n\n`;

        if (Object.keys(ruleDict).includes(category)) {
          ruleDict[category].push({
            name: rule,
            fix: isFixable,
            version: version,
            contents: mdRuleContents,
            sources: mdRuleSources,
          });
        } else {
          ruleDict[category] = [
            {
              name: rule,
              fix: isFixable,
              version: version,
              contents: mdRuleContents,
              sources: mdRuleSources,
            },
          ];
        }
      }
    });

    let mdRules = genMdRules(undefined, false);
    let mdRuleList = genMdRules();

    /* eslint-disable-next-line no-unused-vars */
    Object.entries(ruleDict).forEach(([category, rules]) => {
      rules.forEach(function (rule) {
        mdRules += `${rule.contents}\n\n${rule.sources}\n\n---\n\n`;
      });
    });

    if (mdRuleListCur !== mdRuleList || mdRulesCur !== mdRules) {
      fs.writeFileSync(ruleDocsPath, mdRules, "utf8");
      fs.writeFileSync(ruleListDocsPath, mdRuleList, "utf8");
      console.log("\x1b[38;2;255;140;0m" + "> DOCS UPDATED!" + "\x1b[0m");
    }
  }

  /**
   * Initializes the `cds lint` call and pass the required help content,
   * allowed shortcuts and options to the cds executable
   * @returns Object to return to the cds
   */
  init() {
    const help = this._getEslintHelp();
    const shortcuts = help.match(REGEX_SHORTCUTS).map((str) => str.trim());
    const options = shortcuts.concat(
      help.match(REGEX_OPTIONS).map((str) => str.trim())
    );
    return { help, shortcuts, options };
  }

  async lint(args) {
    args = process.argv.slice(3);

    // Check for ESLint config
    if (!this.projectPath) {
      this.configPath = this._getConfigPath();
      this.projectPath = path.dirname(this.configPath);
    }

    // Check for ESLint v>=6.0.0
    this._checkEslintCmd();

    // Check for local ESLint CDS plugin '@sap/eslint-plugin-cds'
    // If exists, check for validity and completeness
    if (!this.hasEslintCDSPlugin) {
      this.hasEslintCDSPlugin = this._hasEslintCDSPlugin(this.projectPath);
      if (this.hasEslintCDSPlugin) {
        this._checkEslintConfig(this.configPath, ["extends"]);
      }
    }

    if (process.stdout.isTTY) {
      args.unshift("--color");
    }

    const eslintCmdOpts = [...args];

    // Add CDS custom ruledir if exists
    const customCDSRules = path.join(this.projectPath, ".eslint", "rules");
    this.hasCustomCDSRules = this._hasCustomCDSRules(customCDSRules);
    if (
      fs.existsSync(customCDSRules) &&
      fs.statSync(customCDSRules).isDirectory()
    ) {
      if (IS_WIN) {
        eslintCmdOpts.unshift(`"${customCDSRules}"`);
      } else {
        eslintCmdOpts.unshift(`${customCDSRules}`);
      }
      eslintCmdOpts.unshift("--rulesdir");
      this._genDocs(this.projectPath);
    }

    // Add CDS custom formatter
    if (IS_WIN) {
      eslintCmdOpts.unshift(`"${this.eslintPluginPath.replace("index.js", "formatter.js")}"`);
    } else {
      eslintCmdOpts.unshift(`${this.eslintPluginPath.replace("index.js", "formatter.js")}`);
    }
    eslintCmdOpts.unshift("--format");

    // If no local plugin exists, use the cds lint plugin
    // config provided with the cds-dk (recommended)
    if (!this.hasEslintCDSPlugin) {
      this._checkEslintConfig(this.configPath, ["rules"]);
      if (this.eslintRules && this.eslintRules.length > 0) {
        // Allow recommended plugin rules in cds-dk to be overwritten
        // by user by adding rule to cmd line (because of precedence)
        const { rules } = require(this.eslintPluginPath);
        this.eslintRules.forEach((rule) => {
          if (Object.keys(rules).includes(rule.name.replace("@sap/cds/", ""))) {
            eslintCmdOpts.unshift(`"${rule.name}: ${rule.severity}"`);
            eslintCmdOpts.unshift("--rule");
          }
        });
      }
      if (IS_WIN) {
        eslintCmdOpts.unshift(`"${path.join(__dirname, ".eslintrc.js")}"`);
      } else {
        eslintCmdOpts.unshift(`${path.join(__dirname, ".eslintrc.js")}`);
      }
      eslintCmdOpts.unshift("--config");
    }

    // Run ESLint with collected options
    try {
      console.log(
        `Running ${term.info(this.eslintCmd + " " + eslintCmdOpts.join(" "))}\n`
      );
      // cp.execSync will print errors and exit
      cp.execSync(
        `${this.eslintCmd} ${eslintCmdOpts.join(" ")}`,
        {
          cwd: process.cwd(),
          shell: IS_WIN, // for windows only,
          stdio: "inherit",
        }
      );
    } catch (err) {
      // ESLint will yield error report
    }
    return;
  }
}

module.exports = Linter;
