module.exports = Object.assign ( watch, {
  flags: [ '--debug', '--in-memory', '--in-memory?' ],
  options: [ '--port', '--ext', '--livereload', '--open' ],
  help: `
# SYNOPSIS

  *cds watch* [<project>]

  Tells cds to watch for relevant things to come or change in the specified
  project or the current work directory. Compiles and (re-)runs the server
  on every change detected.

# OPTIONS

  *--port* <number>

    Specify the port on which the launched server listens.
    If you specify '0', the server picks a random free port.
    Alternatively, specify the port using env variable _PORT_.

  *--ext* <extensions>

    Specify file extensions to watch for in a comma-separated list.
    *Example:* cds w --ext cds,json,js.

  *--livereload* <port | false>

    Specify the port for the livereload server. Defaults to '35729'.
    Disable it with value _false_.

  *--open* <url>

    Open the given URL (suffix) in the browser after starting.
    If none is given, the default application URL will be opened.

# SEE ALSO

  Actually, *cds watch* is just a convenient shortcut for:
  *cds serve* all --with-mocks --in-memory? ...
  Check out *cds serve ?* to learn more.

`})

const path = require ('path')
const fs = require ('fs')
const t = module.exports.codes = {
  reset: '\x1b[0m', // Default
  bold: '\x1b[1m', // Bold/Bright
  link: '\x1b[4m', // underline
  red: '\x1b[91m', // Bright Foreground Red
  green: '\x1b[32m', // Foreground Green
  yellow: '\x1b[33m', // Foreground Green
  orange: '\x1b[38;2;255;140;0m' // darker orange, works with bright and dark background
}
const extDefaults = 'cds,csn,csv,ts,mjs,cjs,js,json,properties,edmx,xml,env'
let ignore = /node_modules|\.cds-services\.json$/

async function watch ([cwd], {
  args = ['serve', 'all', '--with-mocks'],
  ext = extDefaults,
  ...etc
}={}) {

  args.push (`--${Object.keys(etc).find(a => /^in-memory\??$/.test(a)) || 'in-memory?'}`)
  const env = Object.assign (process.env, { _args: JSON.stringify(args) })
  if (typeof ext !== 'string')  ext = extDefaults
  if ('port' in etc) env.PORT = etc.port
  env.NODE_PATH = path.resolve (__dirname,'../node_modules') // allow global sqlite to be resolved

  let liveReload //= ...
  let firstTime = true
  if (!/false|no/.test(etc['livereload'])) {
    ext += ',css,gif,html,jpg,png,svg'
    liveReload = new (require ('../lib/watch/livereload-server'))
    env.CDS_LIVERELOAD_PATH = require.resolve ('connect-livereload')
    env.CDS_LIVERELOAD_URL = await liveReload.start (etc['livereload'])
      .catch(err => { console.log(`Error starting live reload: ${err.message}`); liveReload = null })
  } else {
    ignore = RegExp(`app${path.sep}.*\\.(js|ts)|`+ignore.source) // exclude more frontend stuff
  }

  const log = (first,...more) => console.log (t.yellow + (first||''), ...more, t.reset)
  if (cwd) {
    const ocwd = process.env._original_cwd = process.cwd()
    if (fs.existsSync(cwd)) log (`cd ${cwd}`)
    else try {
      const resolved = path.dirname (require.resolve(cwd+'/package.json', {paths:[ocwd]}))
      log (`cd ${path.relative(ocwd,cwd = resolved)}`)
    } catch(_){ throw new Error(`No such folder or package: '${ocwd}' -> '${cwd}'`) }
  }
  log ()
  log (`${t.bold}cds ${args.join(' ')}`)
  log (`watching: ${ext}...`)
  if (liveReload) log (`live reload enabled for browsers`)

  const nodemon = require('../lib/watch/node-watch')
  return nodemon ({
    watch: ['*','.env','.cdsrc.json'],
    script:__filename, cwd, env, ext, ignore,
    delay: parseInt(process.env.CDS_WATCH_DELAY) || 200,
    options: etc
  }).on('restart', (files)=>{
    if (liveReload) liveReload.markPending(files)
    if (this.delayed) clearTimeout (this.delayed)
    this.delayed = setTimeout(()=>{
      log (`${t.bold}        _______________________\n`)
      FileHandlers.changed (files)
    }, 111)
  }).on('quit', ()=>{
    log (`${t.bold+t.green}\n[cds] - my watch has ended.\n`)
    process.exit()
  }).on('message', async (msg) => { switch (msg.code) { // messages from child process
    case 'listening':
      env.PORT = (msg.address && msg.address.port) || msg.port
      liveReload && liveReload.reload()
      firstTime && etc['open'] && require('../lib/watch/open').openURL (etc['open'], env.PORT)
      firstTime = false
      break
    case 'EADDRINUSE': env.PORT = 0; _addr_in_use(msg); break
    default: console.error (msg)
  }})
}


const _addr_in_use = (msg) => console.error (`
  ${t.red+t.bold}[EADDRINUSE]${t.reset} - port ${msg.port} is already in use by another server process.
  > Press Return to restart with an arbitrary port.
`)

const FileHandlers = {
  edmx: [ file => (FileHandlers._import || (FileHandlers._import = require ('./import'))) (file) ],
  changed (files) {
    if (files) for (let each of files) {
      const [,ext] = /\.(\w+)$/.exec(each) || []
      for (let handle of this[ext] || [])  handle (each)
    }
  },
}



//
// Child process impl launched by watch
//

if (!module.parent) (async()=>{ // launched by nodemon
  // run through cli in order to use its error handling
  const bootstrap = require('./cds')(...JSON.parse(process.env._args))
  const {cds} = global
  try {
    cds.once('connect', ()=> console.log ('[cds] - using bindings from:', { registry: cds.service.bindings.registry }))
    cds.once('listening', ({server}) => process.send ({ code:'listening', port: server.address().port }))
    await bootstrap
    if (!cds.service.providers.length) return _no_services_found()
  } catch (e) { switch (e.code) {
    case 'NO_SERVICES_FOUND': return _no_services_found(e)
    case 'MODEL_NOT_FOUND': return _no_models_found(e)
    case 'EADDRINUSE': return process.send(e)  //> tell cds watch
    default: console.error(e)
  }}
  function _no_models_found(e) { console.log (`
    No models found in ${cds.resolve(e.model||'*',false)}.
    Waiting for some to arrive...
  `)}
  function _no_services_found() { console.log (`
    No service definitions found in loaded models.
    Waiting for some to arrive...
  `)}
})()
